<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://clnhlzmn.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://clnhlzmn.github.io/blog/" rel="alternate" type="text/html" /><updated>2019-08-09T09:55:44-04:00</updated><id>https://clnhlzmn.github.io/blog/feed.xml</id><title type="html">Colin Holzman</title><subtitle>Mostly an experiment in setting up and running a server/blog. I also occasionally think of things to write about so maybe  I'll do that here.</subtitle><entry><title type="html">Jekyll and pig.js</title><link href="https://clnhlzmn.github.io/blog/programming/2019/04/22/Jekyll-and-PIG.html" rel="alternate" type="text/html" title="Jekyll and pig.js" /><published>2019-04-22T09:00:00-04:00</published><updated>2019-04-22T09:00:00-04:00</updated><id>https://clnhlzmn.github.io/blog/programming/2019/04/22/Jekyll-and-PIG</id><content type="html" xml:base="https://clnhlzmn.github.io/blog/programming/2019/04/22/Jekyll-and-PIG.html">## Photo Gallery

I tried using [Jekyll Lens][Lens] for a photo gallery on [colinholzman.xyz][colinholzman.xyz]. It worked and was easy to use but was not exactly what I wanted. While looking for a better method I came across [this][Basurco] post by Sergio Basurco. In it he describes how he modified the [Jekyll Photo Gallery][JPG] plugin to use [pig.js] for loading images. Pig.js is a simple and lightweight JavaScript library to enable progressive loading of images as the user scrolls to them. The [example](https://feeding.schlosser.io/) is exactly the effect that I was looking for.

## Generating Assets

Pig.js expects to be able to load various sizes for each image. To do this the we must store the images in a manner that allows the pig.js function `urlForSize` to return the path to the image of a given size. I have chosen to store my images like so:

```
├── assets
│   ├── img
│   │   ├── 20
│   │   |   ├── blue.jpg
│   │   |   ...
│   │   ├── 100
│   │   |   ├── red.jpg
│   │   |   ...
│   │   ├── 250
│   │   |   ├── green.jpg
│   │   |   ...
│   │   ├── 500
│   │   │   ├── blue.jpg
...
```

Since my goal is to display potentially hundreds of images like this I need a tool to resize them all and generate the directory structure above.

## gallerybuilder

[gallerybuilder][gallerybuilder] is a simple python script I wrote to take a directory full of photos, resize them all to the sizes required by pig.js, and generate the html for my gallery page. It's a rough draft for now but it does the trick.

## Adding links

One last thing I did to enhance the gallery experience is make each image a link to a full size version. To get the link to the full size image I call `urlForSize` with size equal to 1024. Therefore when creating thumbnail images for the assets folder we have to create sizes 20, 100, 250, 500, (for original pig.js) and 1024 (for full size link). You can see the simple change to pig.js [here][clnhlzmn pig.js].

## Result

You can see what this looks like on my site [here][gallery]. TODO: add a lot more photos.

[Lens]: https://github.com/ElasticDesigns/jekyll-lens
[colinholzman.xyz]: https://colinholzman.xyz
[gallery]: https://colinholzman.xyz/gallery
[Basurco]: https://chuckleplant.github.io/2018/08/06/pig-img-gallery.html
[JPG]: https://github.com/aerobless/jekyll-photo-gallery
[pig.js]: https://github.com/schlosser/pig.js
[clnhlzmn pig.js]: https://github.com/schlosser/pig.js/compare/master...clnhlzmn:master#diff-ded216d1d585dc143459a4bdbbed4626R785
[gallerybuilder]: https://github.com/clnhlzmn/gallerybuilder/blob/master/main.py</content><author><name></name></author><category term="website" /><category term="blog" /><category term="jekyll" /><summary type="html">Photo Gallery</summary></entry><entry><title type="html">CopperKitten</title><link href="https://clnhlzmn.github.io/blog/programming/2019/04/17/copper-kitten.html" rel="alternate" type="text/html" title="CopperKitten" /><published>2019-04-17T17:00:00-04:00</published><updated>2019-04-17T17:00:00-04:00</updated><id>https://clnhlzmn.github.io/blog/programming/2019/04/17/copper-kitten</id><content type="html" xml:base="https://clnhlzmn.github.io/blog/programming/2019/04/17/copper-kitten.html">CopperKitten is an exercise in programming language and runtime design and implementation. Check out the code [here][code] and read on for more explanation.

This project is far from complete. It will probably never be fully complete. I have a few features that I would like to implement before I put it aside. I am writing this post to introduce what I have done so far and invite comments and discussion.

CK is a simple functional language with Hindley Milner type inference. Its compiler and assembler are currently implemented in Kotlin. The compiler ([ckc]), for now, compiles a single 'script' file to its corresponding portable assembly listing, and then the assembler ([cka]) assembles that listing to a portable C99 program. An example of this can be seen in the makefile [here][makefile]. Using the makefile requires java and gcc. The script [simple\_io.ck] is intended to illustrate features of the language that have been implemented so far.

## The Language

### Built-in Types

There are three built in types in CK: `Unit`, `Int`, and `Fun(A, ..., R)`. The first is the usual unit type with exactly one value. The second is a signed integer implemented by the C type `intptr_t`. The third type `Fun(A, ..., R)` is the function type where `A, ...` represents argument types and `R` is the return type. The function type can also be written as `(A, ...) R`.

### User Defined Types

Users can define their own types using a `type ...` declaration at the beginning of a CK file. For example the declaration `type List = (A) nil() | cons(A, List(A))` creates the type `List(A)` where `A` can be any type. User defined types are implemented as a number of compiler generated functions. Pattern matching, when implemented, will use these functions behind the scenes. Until then, the programmer can use them to construct and deconstruct values of user defined types.

### CK Programs

For now a CK program consists of a single .ck file. A .ck file is zero or more declarations followed by an expression. In the [grammar][ck.g4] there are two types of declaration, but for now only `typeDecl` is implemented. The type declarations cause a number of functions to be implemented by the compiler for use in the following expression. Evaluation of the expression in the .ck file is evaluation of the CK program. In the future I would like to add support for multiple files.

### Expressions

The grammar of expressions includes

* unit

  `()`

* integers

  `0`, `1`, `1000000000000000`

* all the usual unary and binary operations on integers

  `a + b`, `-42`, `a || (b &lt;&gt; c)`

  All unary and binary operators take arguments of type `Int` and return values of type `Int`

* functions

  `(a) a`, `(a, b) a + b`, `(n) n * n`

  CK supports limited tail call optimization. For a function call in tail position, if the callee has the same number of arguments as the caller, then the stack frame is reused, otherwise the call will create a new stack frame.

* function applications

  `id(42)`, `add(1, 2)`, `map(aList, (e) e * e)`

  CK uses eager evaluation.

* two forms of conditional expression 

  `cond() ? true() : false()`
  
  `if (cond()) true() else false()`
  
  `if (cond()) true()`
  
  Consequent and alternate expressions of a conditional expression must have the same type. An `if` without an `else` has type `Unit` (that means the consequent must have type `Unit`). Condition expressions must have type `Int` where 0 is false and 1 is true, for now. I intend to add a true boolean type at some point.

* sequence expressions

  `{ a; b }`

  `a` is evaluated and its result discarded, then `b` is evaluated and its value is the value of `{ a; b }`.

* and let expressions 

  `let id = (a) a`, `let rec forever = (f) { f(); forever(f) }`, `{ let id = (a) a; id(42) }`

  The scope of a let expression is the rest of the expressions in its enclosing sequence. That is `{let id = (a) a; id(42)}` can be thought of as `let id = (a) a in id(42)`. 

* tuples and strings are included in the grammar, but they're not yet implemented

Note that type annotations are not required. For clarity the programmer can annotate the types of let bound variables, functions parameters, and function return types using the `: T` syntax. For example `let id: (A) A = (a: A):A a`. Type annotations are not yet fully implemented, but it should be an easy feature to finish. At the moment there are not any situations that _require_ annotations. I would like to add record types and corresponding accessor syntax such as `a.b` which will, as far as I know, require limited type annotations.

### C Language Bindings

Another type of function expression is `cfun`. These can be used any place an ordinary function expression can be used. `cfun` is used to create a binding to a function defined in C for doing IO and whatever else you would rather do in C. In the [example][simple_io.ck] there are two `cfun`s that are used to read and write characters on `stdout`/`stdin`. A `cfun` looks like `cfun id Type` where `id` is the identifier that matches the identifier of the function in C and `Type` is the type of that function. The `native_read` and `native_write` functions are implemented [here][builtin_cfuns.c]. The file that defines the native functions must be compiled and linked with the output from ckc/cka (this is illustrated [here][makefile]).

## Implementation

The implementation of CK includes a compiler, assembler, and runtime.

### Compiler

The CK compiler ([ckc]) takes a single file (program.ck) and compiles it to a CK assembly file (program.cka). Compilation proceeds in a few steps:

1. Parse program.ck using ANTLR4.

   ANTLR4 generates the [classes][generated parser] required to parse a CK file based on the grammar [ck.g4].

2. Convert the ast that is produced by ANTLR to a simpler ast that is easier to work with.

   The class CkBaseVisitor (generated by ANTLR) is extended [here][grammar visitors] to convert the ANTLR generated ast into a [simpler representation][ast]. The CkBaseVisitor extensions are used to parse program.ck [here][parse.kt] and return the simpler ast.

3. Type check the program.

   Type checking is implemented [here][analyze.kt]. The type checker is based on the example implementation at the end of [&quot;Basic Polymorphic Typechecking&quot; by Luca Cardelli][Cardelli].

4. Compile the program.

   Compilation is done by the [CompilationVisitor] class. For now this amounts to visiting the ast and returning a list of assembler instructions.

The [command line option parser][CLI] is used when ckc is invoked on the command line. It parses command line options, reads the input file, performs the compilation steps above, and writes the output to the specified output file.

### Assembler

The CK assembler ([cka]) takes a single program.cka file and converts it to a C99 file. The main task of the assembler is to convert the [abstract assembler syntax][cka.g4] into a list of concrete bytecodes and literal values to be consumed by the runtime vm. Part of cka's task is to generate layout functions to be used by the memory management scheme to identify pointers on the stack and in heap allocated objects. Another thing that the assembler does is combine the program bytecode array, generated functions, and other supporting pieces together into a .c file with a `main` function that initializes the CK runtime and starts execution.

I won't go into too much detail on cka here unless there is interest. It's pretty boring and mostly self explanatory.

The output of cka must be compiled and linked with any files containing definitions of `cfun`s and with the chosen garbage collection implementation file (one of copying\_gc.c, incremental\_gc.c, or mark\_compact\_gc.c). Again, the example [makefile] demonstrates this.

### Runtime

The CK runtime is a simple bytecode interpreter combined with one of three tracing garbage collection implementations. I could have implemented CK by compiling directly to C, rather than using a vm, but I wanted to be able to support tail call optimization and I couldn't see how to do that in plain C.

#### VM

The CK vm is implemented by [vm.h]. Opcodes are enumerated in the type `enum vm_op_code` and are reasonably well documented there. In addition to the usual arithmetic operations there are some for control flow, stack frame management, memory allocation, storing/loading values to/from indices into heap objects/stack frames/function arguments/function captures, and some other miscellaneous operations. Program execution is done by the function `vm_execute` which simply iterates over the given program array dispatching on each op code.

#### Memory Management

There are two copying collectors (one incremental) and one mark compact. I hope they can be used as examples for people who are curious about how garbage collection works. The garbage collectors all depend on [gc\_interface.h] which declares a common set of functions with which the vm can interface with the heap memory. There are probably subtle bugs in the implementations of the garbage collectors. I am most confident in the correctness of the simple copying collector, least confident in the incremental copying collector, and the mark compact collector is somewhere in between.

## Future Work

This is work that I would like to do on this project in the future.

* clean up, organize, and simplify: compiler, assembler, and runtime source files

* integrate programmer type annotations with type checker

* strings and tuples

* pattern matching on instances of user defined types

* modules

* implement parser and CLI in Kotlin (removing ANTLR and Apache CLI dependencies)

* implement compiler and assembler in functional language like ML (or at least in a functional style in Kotlin)

* implement compiler and assembler in CK

* generate machine code rather than C99

* optimize polymorphic functions to not always use boxed types for integers

* lots of other optimizations

Thanks for making it this far! Let me know what you think with a comment below.

[code]: https://github.com/clnhlzmn/CopperKitten
[makefile]: https://github.com/clnhlzmn/CopperKitten/blob/master/example/simple/makefile
[simple_io.ck]: https://github.com/clnhlzmn/CopperKitten/blob/master/example/simple/simple_io.ck
[ck.g4]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/grammar/ck.g4
[cka.g4]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/cka/grammar/cka.g4
[builtin_cfuns.c]: https://github.com/clnhlzmn/CopperKitten/blob/master/runtime/builtin_cfuns.c
[ckc]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/
[cka]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/cka/
[generated parser]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/gen/
[grammar visitors]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/src/ck/grammar/visitors
[ast]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/src/ck/ast/node/
[parse.kt]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/src/ck/grammar/Parse.kt
[analyze.kt]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/src/ck/analyze/Analyze.kt
[Cardelli]: http://lucacardelli.name/Papers/BasicTypechecking.pdf
[CompilationVisitor]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/src/ck/ast/visitors/CompilationVisitor.kt
[CLI]: https://github.com/clnhlzmn/CopperKitten/blob/master/compiler/ckc/src/ck/Cli.kt
[vm.h]: https://github.com/clnhlzmn/CopperKitten/blob/master/runtime/vm.h
[gc_interface.h]: https://github.com/clnhlzmn/CopperKitten/blob/master/runtime/gc_interface.h</content><author><name></name></author><category term="languages" /><category term="cs" /><category term="design" /><summary type="html">CopperKitten is an exercise in programming language and runtime design and implementation. Check out the code here and read on for more explanation.</summary></entry><entry><title type="html">website updates</title><link href="https://clnhlzmn.github.io/blog/internet/2018/12/07/website-updates.html" rel="alternate" type="text/html" title="website updates" /><published>2018-12-07T16:24:00-05:00</published><updated>2018-12-07T16:24:00-05:00</updated><id>https://clnhlzmn.github.io/blog/internet/2018/12/07/website-updates</id><content type="html" xml:base="https://clnhlzmn.github.io/blog/internet/2018/12/07/website-updates.html">### Photos

There are some really neat themes for Jekyll for all sorts of things. I found one for a photo gallery and set it up at [colinholzman.xyz/photos](https://colinholzman.xyz/photos). Not a lot of photos up there at the moment, but that'll change.  

The theme I used is called [Lens](https://github.com/ElasticDesigns/jekyll-lens). It works similarly to default Jekyll. Put your photos in one place, run `jekyll build` and you'll have the static site ready to serve, in my case, with `app.use('/photos', express.static('/home/admin/photos'));`.

### Resume

[colinholzman.xyz/resume.pdf](https://colinholzman.xyz/resume.pdf) has a pdf of my resume. This is simply 
```
const resume = fs.readFileSync(path.join(__dirname, 'resume.pdf'));
app.get('/resume.pdf', (req, res) =&gt; {
    res.send(resume);
});
```
on the server.  

I should probably update my resume.

### Webcam

I used an old USB webcam, a rasberry pi 3 B, and [motionEyeOs](https://github.com/ccrisan/motioneyeos) to set up a stream of my backyard at [colinholzman.xyz/cam](http://colinholzman.xyz/cam). Download the latest image of motionEyeOs for your device from [here](https://github.com/ccrisan/motioneyeos/wiki/Supported-Devices). For a RPi burn the image on a sd card (I used etcher on my mac). Plug in the camera, insert the sd card, and connect the Pi to the network and power. Then go to the Pi's address in your browser to set up all the options. There are a lot of options to configure but the camera and stream worked out of the box.  

I forwarded the video streaming port through my router and that enabled me to access the stream from the internet. On the colinholzman.xyz server I added 
```
app.get('/cam', (req, res) =&gt; {
    res.sendFile(path.join(__dirname, 'cam.html'));
});
```
where cam.html just has an iframe pointing to my home router on the motionEyeOs streaming port. It seems to work OK. It doesn't work over https though. I wonder why?</content><author><name></name></author><summary type="html">Photos</summary></entry><entry><title type="html">colinholzman.xyz</title><link href="https://clnhlzmn.github.io/blog/meta/2018/11/27/colinholzman-xyz.html" rel="alternate" type="text/html" title="colinholzman.xyz" /><published>2018-11-27T07:00:00-05:00</published><updated>2018-11-27T07:00:00-05:00</updated><id>https://clnhlzmn.github.io/blog/meta/2018/11/27/colinholzman-xyz</id><content type="html" xml:base="https://clnhlzmn.github.io/blog/meta/2018/11/27/colinholzman-xyz.html">I've wanted to learn what it takes to run a website. Finally I've put together [colinholzman.xyz](https://colinholzman.xyz). This is based on knowledge found all over the internet and through trial and error. It's fitting to write down some instructions on how to reproduce it as the first post.

### get a host to serve your site

I used Amazon Lightsail for this. This site is currently running on the cheapest instance I could get (512 MB RAM, 1 vCPU, 20 GB SSD). It's running Debian 8.

### domain name

Buy a domain name from someone like [porkbun.com](https://porkbun.com). Once you have an account you can create a record that will return the static ip that you assign to your server when someone asks for the address of colinholzman.xyz or whatever.

### install node.js

Do this in whatever way is typical for your os. I think Amazon has images with node already installed.

### install express, forever, and probably some other things

`npm install express`
`npm install forever`
`...`

### create a file server.js 
  
Here is a simple static http server (a pretty trivial use of express I'm sure):

    // Dependencies
    const fs = require('fs');
    const http = require('http');
    const express = require('express');
    
    const app = express();
    
    app.use(express.static('/home/admin/site'))
    
    // Starting http server
    const httpServer = http.createServer(app);
    
    httpServer.listen(80, () =&gt; {
        //console.log('HTTP Server running on port 80');
    });

Run it like `sudo forever start server.js`. We want to use https though!

### Let's Encrypt

In order to get the nice secure looking green lock when you visit your site you'll have to obtain some on-the-level ssl certificates. To do this we go to [certbot.eff.org](https://certbot.eff.org/) and download the certbot-auto tool. There are pretty solid instructions there. It comes down to running something like `sudo ./path/to/certbot-auto certonly --webroot -d colinholzman.xyz`. With the certificate generated make `server.js` look like this:

    // Dependencies
    const fs = require('fs');
    const https = require('https');
    const express = require('express');
    
    const app = express();
    
    // Certificate
    const privateKey = fs.readFileSync('/etc/letsencrypt/live/colinholzman.xyz/privkey.pem', 'utf8');
    const certificate = fs.readFileSync('/etc/letsencrypt/live/colinholzman.xyz/cert.pem', 'utf8');
    const ca = fs.readFileSync('/etc/letsencrypt/live/colinholzman.xyz/chain.pem', 'utf8');
    
    const credentials = {
        key: privateKey,
        cert: certificate,
        ca: ca
    };
    
    app.use(express.static('/home/admin/site'))
    
    // Starting https server
    const httpsServer = https.createServer(credentials, app);
    
    httpsServer.listen(443, () =&gt; {
        //console.log('HTTPS Server running on port 443');
    });

### Jekyll

[Jekyll](https://jekyllrb.com/) is a static website generator. It takes a bunch of markdown content and puts it into place using templates and creates the html and other stuff that gets served from `/home/admin/site`.</content><author><name></name></author><summary type="html">I’ve wanted to learn what it takes to run a website. Finally I’ve put together colinholzman.xyz. This is based on knowledge found all over the internet and through trial and error. It’s fitting to write down some instructions on how to reproduce it as the first post.</summary></entry></feed>